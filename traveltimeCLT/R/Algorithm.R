#' Created by Adrien Hernandez and Mohamad Elmasri
#' Travel time estimation modelling using Central Limit Theorem
#'
#' This function allows to run the algorithm on the train set to get the mean of the autocorrelation and the mean of the residuals
#' @param obj.data.train This is the output dataframe generated by the Graph.traveltimeCLT function.
#' @param obj.graph.stat.full This is the dataframe containing all necessary statistics ouputs of the graph generated by the Graph.traveltimeCLT function.
#' @param M The number of samples we want to use from our train set. This can be useful especially with applying the travel time estimation algorithm on a specific timebin.
#' @param bin Allows to select a specific timebin from the dataset.
#' @param rules Need to represent a list containing, start, end, days and tag for each timebin of the dataset (see example).
#' @examples
#' traveltimeCLT(obj.data.train = graph.traveltimeCLT$data.train, obj.graph.stat.full = graph.traveltimeCLT, M = 1000, bin = "MR", rules = list(list(start='6:30', end= '9:00', days = 0:6, tag='MR'),list(start='15:00', end= '18:00', days = 0:6, tag='ER')))
#' @import data.table
#' @import traveltimeHMM
#' @export

traveltimeCLT <- function(obj.data.train = NULL, obj.graph.stat.full = NULL, M = NULL, bin = NULL, rules = NULL){

  set.seed(2020)

  # A.0 Sampling train dataset according to model input
  t = obj.data.train[, .N , by=trip][N>10][, trip]
  sample_timebin = obj.data.train[trip %in% t, .(timeBins= if(all(timeBins == timeBins[1])) timeBins[1] else 'remove' ), by=trip]
  sample_timebin = sample_timebin[!timeBins == 'remove']

  if(is.null(bin)){
    samp = sample_timebin[, trip]
    tt = obj.data.train
    xx = tt[, .I[.N>10],by = trip]
  } else {
    samp = sample_timebin[timeBins == bin][, trip]
    samp = samp[sample.int(length(samp),M)]
    tt = obj.data.train[trip %in% samp]
    xx = tt[trip %in% samp, .I[.N>10],by = trip]
  }

  # A.1 Get rho. The algorithm only keeps trips ("trips") that have more than 10 ijk links.
  # On these links, we will create and use a function called "get rho" allowing to calculate
  # the autocovariance of the speed with a lag up to 5 for each trip.
  # If desired, the function also allows calculation specifically for AM or PM timebins.
  rho = tt[xx$V1][,    drop((acf((1/speed - mean)/(sd+1e-5), plot=FALSE, lag.max=5))[[1]]), by = trip]
  a = rho[, V1[2] ,by = trip][, V1]
  rho = round(mean(a), 2)
  print(paste0("Mean of autocorrelation: ", rho))

  # A.2 Model computation through the param_zeta function:
  # Now, we create our model which is a function (param_zeta), allowing to calculate the cumulative
  # variance and taking as parameters: t0 (a real time which will be converted into time bins by a
  # function calling the package traveltimeHMM), rho, linkfrom, linkto, len and sequence = FALSE.

  # The param_zeta function uses 2 loops: The first calculates the cumulative variance for all links - 1
  # (without the last link which is a NA) per trip.
  # The second loop takes into account the missing value for the LinkId.to of the last link of ijk,
  # since there is no destination for the last link of the route.
  # The cumulative variance is calculated in each loop by this line of code:

  # Where vcumlative adjusts to each iteration of the loop; len [i] ^ 2 is the distance traveled for each
  # link ijk to the square; d $ sd2 is the standard deviation of the speed for each ijk link of each trip;
  # rho is the autocovariance of the speed calculated by the function get_rho; lenprev is the distance traveled
  # to the previous link (lenprev = 1, for the first ijk link of each trip); vprev is the variance of the previous
  # link (vprev = 1, for the first ijk link of each trip).

  # This function has 2 outputs:
  # tt (traveltime): It represents the distance for the link ijk * the average speed for the same link ijk. (t = 0, for the first ijk link of each trip).
  # S : It is the square root of the cumulative variance for each ijk link.

  param_zeta<-function(t0, rho,linkfrom, linkto, len, sequence = FALSE){
    t0 = as.POSIXlt(t0)
    time_bins <- rules2timebins(rules)
    tbin = time_bins(t0)
    g = obj.graph.stat.full[linkId.from %in% linkfrom]
    t = 0
    vcumlative = 0
    vprev = 1
    lenprev = 1
    if(sequence){
      t.seq = v.seq = numeric(length(len))
    }
    for(i  in 1:(length(len) - 1)){
      d = g[linkId.from == linkfrom[i] & linkId.to == linkto[i] & timeBins == tbin]
      t = t + len[i]*d$mean
      tbin = time_bins(t0 + t)
      vcumlative = vcumlative + len[i]^2  * d$sd^2  + 2*rho* len[i]*lenprev * d$sd * vprev
      vprev = d$sd
      lenprev = len[i]
      if(sequence){
        v.seq[i] = vcumlative
        t.seq[i] = t
      }
    }
    i = i+1
    if(is.na(linkto[i])){
      d = g[linkId.from == linkfrom[i] & timeBins == tbin & is.na(linkId.to)]
    }else{
      d = g[linkId.from == linkfrom[i] & linkId.to == linkto[i] & timeBins == tbin]
    }
    t = t + len[i]*d$mean
    vcumlative = vcumlative + len[i]^2 * d$sd^2 + 2* rho * len[i]*lenprev *d$sd *vprev
    if(sequence){
      v.seq[i] = vcumlative
      t.seq[i] = t
    }
    s = sqrt(vcumlative)
    if(sequence){
      list(tt =t, sd = s, v.seq = sqrt(v.seq), t.seq = t.seq)
    }else{
      list(tt =t, sd = s)
    }}

  # A.3 Residual variance.
  # We create a residual variance function, allowing to supply the residual variance taking as input: DB (data), rho, etsamp = NULL.
  # This function uses the param_zeta function seen above.

  # First, it calculates obstt, which is the sum of tt (travel time) for each trip.
  # Then we add to the data D a column of the residues called res and calculated in the following way:
  if(is.null(samp)){
    A = obj.data.train[order(trip, time)]
  } else{
    A = obj.data.train[trip %in% samp][order(trip, time)]}
  B = A[, param_zeta(time[1], rho, linkId.from, linkId.to, length), by = trip]
  D = merge(B, A[, .(obstt= sum(tt)), trip])
  D[, res := (obstt - tt)/sd]
  res = list(db = D, res.sd = sd(D$res))
  v = res$res.sd
  print("This is the mean of the residuals")
  print(v)


  # Returning variables
  obj <- list(variance = v, rho = rho)

  class(obj) = append(class(obj), "traveltime", after=0)

  invisible(obj)
}
